<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Java基础 | wuyp&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="学习路线大纲 基础Java语言是美国Sun公司 Stanford university network 1995年推出的高级编程语言。所谓编程语言，是计算机语言，人们可以使用编程语言对计算机下达命令，让计算机完成人们的需求。  发展历程 1995年Sun公司发布了Java1.0版本 2004年发布Java5 版本 2009年oracle甲骨文公司收购了Sun公司 2014年发布了Java8版本 2">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础">
<meta property="og:url" content="http://example.com/2021/06/11/Java%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="wuyp&#39;s blog">
<meta property="og:description" content="学习路线大纲 基础Java语言是美国Sun公司 Stanford university network 1995年推出的高级编程语言。所谓编程语言，是计算机语言，人们可以使用编程语言对计算机下达命令，让计算机完成人们的需求。  发展历程 1995年Sun公司发布了Java1.0版本 2004年发布Java5 版本 2009年oracle甲骨文公司收购了Sun公司 2014年发布了Java8版本 2">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/wuyueping/images/raw/master/img/Java_20211109201325.png">
<meta property="og:image" content="https://gitee.com/wuyueping/images/raw/master/img/idea_20211129210035.png">
<meta property="og:image" content="https://gitee.com/wuyueping/images/raw/master/img/javase_20211202194830.png">
<meta property="og:image" content="https://gitee.com/wuyueping/images/raw/master/img/javase_20211203190806.png">
<meta property="og:image" content="https://gitee.com/wuyueping/images/raw/master/img/javase_20211203193154.png">
<meta property="og:image" content="https://gitee.com/wuyueping/images/raw/master/img/20211203193507.png">
<meta property="og:image" content="https://gitee.com/wuyueping/images/raw/master/img/static_20210621151752.jpeg">
<meta property="og:image" content="https://gitee.com/wuyueping/images/raw/master/img/extends_20210623163209.jpeg">
<meta property="article:published_time" content="2021-06-11T02:26:33.823Z">
<meta property="article:modified_time" content="2021-12-03T13:57:38.598Z">
<meta property="article:author" content="wuyp">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/wuyueping/images/raw/master/img/Java_20211109201325.png">
  
    <link rel="alternate" href="/atom.xml" title="wuyp&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Noto+Sans+KR:100,300,400,700&amp;subset=korean" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <!--<div id="banner"></div>-->
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        <a href="/" id="main-nav-title" class="main-nav-link">wuyp&#39;s blog</a>
        <div class="header_menu">
          
            <a class="main-nav-link" href="/">主页</a>
          
            <a class="main-nav-link" href="/archives/">归档</a>
          
            <a class="main-nav-link" href="/about/">关于.</a>
          
        </div>
      </nav>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Java基础" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Java基础
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      <div class="article-entry-part">
        
          <h1 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h1><h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><p><img src="https://gitee.com/wuyueping/images/raw/master/img/Java_20211109201325.png" alt="Java基础"></p>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>Java语言是美国Sun公司 Stanford university network 1995年推出的高级编程语言。所谓编程语言，是计算机语言，人们可以使用编程语言对计算机下达命令，让计算机完成人们的需求。</p>
<ul>
<li>发展历程<ul>
<li>1995年Sun公司发布了Java1.0版本</li>
<li>2004年发布Java5 版本</li>
<li>2009年oracle甲骨文公司收购了Sun公司</li>
<li>2014年发布了Java8版本</li>
<li>2018年3月发布了Java10版本</li>
</ul>
</li>
<li>应用<ul>
<li>互联网程序的开发领域</li>
<li>大数据</li>
</ul>
</li>
</ul>
<h2 id="计算机基础知识"><a href="#计算机基础知识" class="headerlink" title="计算机基础知识"></a>计算机基础知识</h2><h3 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h3><p>计算机中全部采用二进制。</p>
<ul>
<li>二进制<ul>
<li>它只包含0、1两个数字，逢二进一。</li>
<li>十进制和二进制的转换</li>
</ul>
</li>
</ul>
<h3 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h3><p>字节是常见的计算机最小的存储单元。</p>
<p>位 bit : 一个数字0或者一个数字1，代表一位</p>
<p>字节 Byte : 每逢8位是一个字节，这是数据存储的最小单位。</p>
<p>1Byte = 8 bit</p>
<p>1MB = 1024 KB</p>
<p>GB</p>
<p>TB</p>
<p>TB</p>
<p>EB</p>
<p>ZB</p>
<h3 id="命令提示符"><a href="#命令提示符" class="headerlink" title="命令提示符"></a>命令提示符</h3><h3 id="跨平台"><a href="#跨平台" class="headerlink" title="跨平台"></a>跨平台</h3><p>Java虚拟机JVM</p>
<ul>
<li>JVM<ul>
<li>Java虚拟机，是运行所有Java程序的假想计算机，是Java程序的运行环境。我们编写的Java代码，都运行在JVM上。</li>
<li>跨平台：任何软件的运行，都必须要运行在操作系统上，而我们用Java编写的软件可以运行在任何的操作系统上，这个特性就是Java语言的跨平台特性。该特性由Java实现，我们编写的程序运行在JVM上，而JVM运行在操作系统上</li>
<li>Java的虚拟机本身不具备跨平台功能的，每个操作系统下都有不同版本的虚拟机。</li>
</ul>
</li>
</ul>
<h3 id="JRE、JDK"><a href="#JRE、JDK" class="headerlink" title="JRE、JDK"></a>JRE、JDK</h3><ul>
<li>JRE<ul>
<li>是Java程序的运行环境，包含JVM和运行时所需要的核心类库。</li>
</ul>
</li>
<li>JDK<ul>
<li>是Java程序开发的恶工具包，包含JRE和开发人员使用的工具。</li>
</ul>
</li>
</ul>
<h3 id="Java安装和环境变量配置-略"><a href="#Java安装和环境变量配置-略" class="headerlink" title="Java安装和环境变量配置(略)"></a>Java安装和环境变量配置(略)</h3><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul>
<li>单行注释</li>
<li>多行注释</li>
<li>文档注释<ul>
<li>文档注释以<code>/**</code> 开头，以<code>*/</code>结束。</li>
<li>Javadoc生成API帮助文档，Java帮助文档主要用来说明类、成员变量和方法的功能。Javadoc可以从程序源代码中抽取类、方法、成员等注释，然后形成一个和源代码配套的API帮助文档。</li>
<li>API帮助文档相当于产品说明书，而说明书只需要介绍那些供用户使用的部分，所以Javadoc默认只提取public、protected修饰的部分，如果要提取private修饰的部分，需要使用-private。</li>
</ul>
</li>
</ul>
<p>Javadoc 工具可以识别文档注释中的一些特殊标签，这些标签一般以<code>@</code>开头，后跟一个指定的名字，有的也以<code>&#123;@</code>开头，以<code>&#125;</code>结束。Javadoc 可以识别的标签如下表所示：</p>
<table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>@author</td>
<td>标识一个类的作者，一般用于类注释</td>
<td>@author description</td>
</tr>
<tr>
<td>@deprecated</td>
<td>指名一个过期的类或成员，表明该类或方法不建议使用</td>
<td>@deprecated description</td>
</tr>
<tr>
<td>{@docRoot}</td>
<td>指明当前文档根目录的路径</td>
<td>Directory Path</td>
</tr>
<tr>
<td>@exception</td>
<td>可能抛出异常的说明，一般用于方法注释</td>
<td>@exception exception-name explanation</td>
</tr>
<tr>
<td>{@inheritDoc}</td>
<td>从直接父类继承的注释</td>
<td>Inherits a comment from the immediate surperclass.</td>
</tr>
<tr>
<td>{@link}</td>
<td>插入一个到另一个主题的链接</td>
<td>{@link name text}</td>
</tr>
<tr>
<td>{@linkplain}</td>
<td>插入一个到另一个主题的链接，但是该链接显示纯文本字体</td>
<td>Inserts an in-line link to another topic.</td>
</tr>
<tr>
<td>@param</td>
<td>说明一个方法的参数，一般用于方法注释</td>
<td>@param parameter-name explanation</td>
</tr>
<tr>
<td>@return</td>
<td>说明返回值类型，一般用于方法注释，不能出现再构造方法中</td>
<td>@return explanation</td>
</tr>
<tr>
<td>@see</td>
<td>指定一个到另一个主题的链接</td>
<td>@see anchor</td>
</tr>
<tr>
<td>@serial</td>
<td>说明一个序列化属性</td>
<td>@serial description</td>
</tr>
<tr>
<td>@serialData</td>
<td>说明通过 writeObject() 和 writeExternal() 方法写的数据</td>
<td>@serialData description</td>
</tr>
<tr>
<td>@serialField</td>
<td>说明一个 ObjectStreamField 组件</td>
<td>@serialField name type description</td>
</tr>
<tr>
<td>@since</td>
<td>说明从哪个版本起开始有了这个函数</td>
<td>@since release</td>
</tr>
<tr>
<td>@throws</td>
<td>和 @exception 标签一样.</td>
<td>The @throws tag has the same meaning as the @exception tag.</td>
</tr>
<tr>
<td>{@value}</td>
<td>显示常量的值，该常量必须是 static 属性。</td>
<td>Displays the value of a constant, which must be a static field.</td>
</tr>
<tr>
<td>@version</td>
<td>指定类的版本，一般用于类注释</td>
<td>@version info</td>
</tr>
</tbody></table>
<p>对两种标签格式的说明：</p>
<ul>
<li>@tag 格式的标签（不被<code>&#123; &#125;</code>包围的标签）为块标签，只能在主要描述（类注释中对该类的详细说明为主要描述）后面的标签部分（如果块标签放在主要描述的前面，则生成 API 帮助文档时会检测不到主要描述）。</li>
<li>{@tag} 格式的标签（由<code>&#123; &#125;</code>包围的标签）为内联标签，可以放在主要描述中的任何位置或块标签的注释中。</li>
</ul>
<p>Javadoc 标签注意事项：</p>
<ul>
<li>Javadoc 标签必须从一行的开头开始，否则将被视为普通文本。</li>
<li>一般具有相同名称的标签放在一起。</li>
<li>Javadoc 标签区分大小写，代码中对于大小写错误的标签不会发生编译错误，但是在生成 API 帮助文档时会检测不到该注释内容。</li>
</ul>
<h4 id="Javadoc命令"><a href="#Javadoc命令" class="headerlink" title="Javadoc命令"></a>Javadoc命令</h4><p>Javadoc 用法格式如下：</p>
<p>javadoc [options] [packagenames] [sourcefiles]</p>
<p>对格式的说明：</p>
<ul>
<li>options 表示 Javadoc 命令的选项；</li>
<li>packagenames 表示包名；</li>
<li>sourcefiles 表示源文件名。</li>
</ul>
<p>在 cmd（命令提示符）中输入<code>javadoc -help</code>就可以看到 Javadoc 的用法和选项（前提是安装配置了JDK），下面列举 Javadoc 命令的常用选项：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-public</td>
<td>仅显示 public 类和成员</td>
</tr>
<tr>
<td>-protected</td>
<td>显示 protected/public 类和成员（默认值）</td>
</tr>
<tr>
<td>-package</td>
<td>显示 package/protected/public 类和成员</td>
</tr>
<tr>
<td>-private</td>
<td>显示所有类和成员</td>
</tr>
<tr>
<td>-d <directory></td>
<td>输出文件的目标目录</td>
</tr>
<tr>
<td>-version</td>
<td>包含 @version 段</td>
</tr>
<tr>
<td>-author</td>
<td>包含 @author 段</td>
</tr>
<tr>
<td>-splitindex</td>
<td>将索引分为每个字母对应一个文件</td>
</tr>
<tr>
<td>-windowtitle <text></td>
<td>文档的浏览器窗口标题</td>
</tr>
</tbody></table>
<h4 id="文档注释的格式"><a href="#文档注释的格式" class="headerlink" title="文档注释的格式"></a>文档注释的格式</h4><p>在编写文档注释的过程中，有时需要添加 HTML 标签，比如：需要换行时，应该使用<code>&lt;br&gt;</code>，而不是一个回车符；需要分段时，应该使用<code>&lt;p&gt;</code>。</p>
<p>Javadoc 并不是将代码中的文档注释直接复制到帮助文档的 HTML 文件中，而是读取每一行后，删除前面的<code>*</code>号及<code>*</code>以前的空格再输入到 HTML 文档。</p>
<p>/**<br>* first line.<br>******* second line.<br>* third line.<br>*/</p>
<p>编译输出后的 HTML 源码如下所示。</p>
<p>first line. <br><br>second line. <br><br>third line.</p>
<p>注释前面的<code>*</code>号允许连续使用多个，其效果和使用一个<code>*</code>号一样，但多个<code>*</code>前不能有其他字符分隔，否则分隔符及后面的<code>*</code>号都将作为文档的内容。</p>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><ul>
<li>特点<ul>
<li>完全小写的字母</li>
<li>增强版记事本🗒️有特殊颜色</li>
</ul>
</li>
</ul>
<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><ul>
<li>命名规则<ul>
<li>包含英文26个字母(区分大小写)、数字、美元符号$、下划线_</li>
<li>不能以数字开头</li>
<li>不能是关键字</li>
</ul>
</li>
<li>命名规范<ul>
<li>类名规范<ul>
<li>首字母大写，后面每个单词首字母大写(大驼峰式)</li>
</ul>
</li>
<li>变量名规范<ul>
<li>首字母小写，后面每个单词首字母大写(小驼峰式)</li>
</ul>
</li>
<li>方法名规范：同变量名</li>
</ul>
</li>
</ul>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>Java程序运行期间固定不变的量。</p>
<ul>
<li>字符串常量 ： 双引号</li>
<li>整数常量：直接写上的数字，没有小数点</li>
<li>浮点数常量：直接写上的数字，有小数点</li>
<li>字符常量：单引号引起来的单个字符。两个 单引号中间必须有且仅有一个字符，多个不行。</li>
<li>布尔常量：true、false</li>
<li>空常量：null 代表没有任何数据。空常量不能直接用来打印输出。</li>
</ul>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul>
<li>基本数据类型 四类八种<ul>
<li>整数型 byte short int long</li>
<li>浮点型 float double</li>
<li>字符型 char 内存占用2个字节</li>
<li>布尔型 boolean</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>数据类型</th>
<th></th>
<th>内存占有</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>字节型</td>
<td>byte</td>
<td>1个字节</td>
<td>-128～127</td>
</tr>
<tr>
<td>短整型</td>
<td>short</td>
<td>2个字节</td>
<td></td>
</tr>
<tr>
<td>整型</td>
<td>int</td>
<td>4个字节</td>
<td></td>
</tr>
<tr>
<td>长整型</td>
<td>long</td>
<td>8个字节</td>
<td></td>
</tr>
<tr>
<td>单精度浮点数</td>
<td>float</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>双精度浮点数</td>
<td>double</td>
<td>8</td>
<td></td>
</tr>
<tr>
<td>字符型</td>
<td>char</td>
<td>2</td>
<td>0～65535</td>
</tr>
<tr>
<td>布尔型</td>
<td>boolean</td>
<td>1</td>
<td>true、false</td>
</tr>
</tbody></table>
<ul>
<li>引用数据类型<ul>
<li>字符串、数组、类、接口、lambda</li>
</ul>
</li>
</ul>
<p>说明</p>
<p>1、字符串不是基本类型、而是引用类型</p>
<p>2、浮点型只是一个近似值，并非精确的值</p>
<p>3、数据范围与字节数不一定相关，例如float数据范围比long更加广泛，但是float是4字节，long是8字节</p>
<p>4、浮点数默认类型是double，如果要使用float类型，需要加上后缀F；</p>
<p>​    如果是整数，默认是int类型，如果要使用long类型，需要加上后缀L。推荐使用大写字母后缀。</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>程序运行期间，内容可以发生改变的量。</p>
<p>数据类型  变量名称 ;</p>
<p>变量名称 = 数据值 ;</p>
<p>数据类型   变量名称  = 数据值 ;</p>
<p>说明：</p>
<p>char类型可以写入一个中文字。</p>
<p>1、如果创建多个变量，那么变量之间的名称不可以重复</p>
<p>2、对于float和long类型来说，字符后缀F和L不要丢掉</p>
<p>3、如果使用byte或者short类型的变量，那么右侧的数据值不能超过左侧类型的范围 </p>
<p>4、没有进行复制的变量，不能直接使用，一定要赋值之后，才能使用</p>
<p>5、变量的使用不能超过作用域范围 【作用域：从定义变量的哪一行开始，一直到直接所属的大括号结束为止】</p>
<p>6、可以通过一个语句来创建多个变量，但是一般不推荐。</p>
<h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><p>当数据类型不一致时，将会发生数据类型转换。</p>
<ul>
<li>自动转换(隐氏)<ul>
<li>数据范围从小到大</li>
<li>代码不需要进行特殊处理，自动完成。</li>
</ul>
</li>
<li>强制转换<ul>
<li>范围小的类型 范围小的变量名 = (范围小的类型) 原本范围大的数据</li>
<li>一般不推荐使用，因为有可能发生精度损失、数据溢出。</li>
<li>byte/short/char 这三种类型都可以发生数学运算，例如加法”+”</li>
<li>byte/short/char 这三种类型在运算的时候，都会被首先提升为int类型，然后再计算。</li>
<li>boolean 类型不能发生数据类型转换。</li>
</ul>
</li>
</ul>
<h3 id="ASCII码表"><a href="#ASCII码表" class="headerlink" title="ASCII码表"></a>ASCII码表</h3><p>数字和常见字符的对应关系</p>
<p>ASCII码表：美国信息交换标准代码</p>
<p>Unicode码表：万国表。也是数字和符号的对照关系，开头0-127和ascii完全一样。包含从128开始的更多字符。</p>
<table>
<thead>
<tr>
<th>48</th>
<th>0</th>
</tr>
</thead>
<tbody><tr>
<td>65</td>
<td>A</td>
</tr>
<tr>
<td>97</td>
<td>a</td>
</tr>
<tr>
<td>20013</td>
<td>中</td>
</tr>
</tbody></table>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>运算符：进行特定操作的符号</p>
<p>表达式：</p>
<ul>
<li>算数运算符<ul>
<li>四则运算 + 取模 %(取余数)<ul>
<li>对于一个整数的表达式来说，除数用的是整除，整数除以整数，结果仍然是整数，只看商，不看余数。</li>
</ul>
</li>
<li>加号➕<ul>
<li>对于数值来说，就是加法</li>
<li>对于字符char类型来说，在计算之前，char会被提升成为int ，然后再计算</li>
<li>对于字符串String，加号代表字符串连接操作。</li>
</ul>
</li>
<li>自增<ul>
<li>++</li>
</ul>
</li>
<li>自减<ul>
<li>–</li>
<li>单独使用，前++和后++没有任何区别。</li>
<li>混合使用<ul>
<li>【前++】，那么变量先+1，然后拿着结果进行使用。【先加后用】</li>
<li>【后++】，那么首先使用变量原来的值，然后再让变量+1。【先用后加】</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>赋值运算符  =      +=       * =       / =       - =       % =<ul>
<li>复合赋值运算符其中隐含了一个强制类型转换。</li>
</ul>
</li>
<li>比较运算符     ==         &lt;          &gt;       &lt;=        &gt;=         !=<ul>
<li>比较运算符的结果一定是一个boolean值</li>
<li>如果进行多次判断，不能连着写。</li>
</ul>
</li>
<li>逻辑运算符        &amp;&amp;      ||      !<ul>
<li>具有短路效果，如果根据左边已经可以判断得到的最终结果，那么右边的代码将不再执行，从而节省一定的性能。</li>
</ul>
</li>
<li>三元运算符              <ul>
<li>数据类型    变量名称      =    条件判断     ?      表达式A        :           表达式B</li>
</ul>
</li>
</ul>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>方法名称的命名规则和变量一样，使用小驼峰。</p>
<p>方法体：也就是大括号当中可以包含任意条语句</p>
<p>说明：</p>
<p>1、方法定义的先后顺序无所谓</p>
<p>2、方法的定义不能产生嵌套包含关系</p>
<p>3、方法定义好了之后，不会执行。如果想要执行，一定要进行方法的【调用】</p>
<ul>
<li>参数<ul>
<li>有参数</li>
<li>无参数</li>
</ul>
</li>
<li>返回值<ul>
<li>有返回值</li>
<li>无返回值</li>
</ul>
</li>
</ul>
<p>修饰符 返回值类型 方法名称(参数类型 参数名称 ,  … ) {方法体 ; return 返回值 ; }</p>
<p>调用方法—-找到方法—-参数传递—-执方法体—-带着返回值回到方法的调用处</p>
<p>调用方法—-找到方法—-传递参数—-执行方法体—-直接结束</p>
<h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><p>方法名称();</p>
<h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><p> 多个方法的名称一样，但是参数列表不一样。</p>
<p>1.参数个数不同</p>
<p>2.参数类型不同</p>
<p>3.参数的多类型顺序不同</p>
<h2 id="编译器优化"><a href="#编译器优化" class="headerlink" title="编译器优化"></a>编译器优化</h2><ul>
<li>对于byte/short/char三种类型来说，如果右侧赋值的数值没有超过范围，那么javac编译器会自动隐含地为我们补上一个 (byte)/(shor)/(char)</li>
<li>在给变量进行赋值的时候，如果右侧的表达式当中全都是常量，没有任何变量，那么编译器javac将会直接将若干个常量表达式计算得到结果。== 编译器的常量优化。</li>
</ul>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h3><h3 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h3><ul>
<li><p>判断语句 if</p>
<ul>
<li>if…..else if……else……</li>
<li>三元运算符</li>
</ul>
</li>
<li><p>switch</p>
<ul>
<li>表达式<ul>
<li>基本数据类型</li>
<li>String字符串、enum枚举</li>
</ul>
</li>
<li>语句灵活，前后顺序可以颠倒，而且break语句还可以省略。</li>
</ul>
</li>
</ul>
<h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><ol>
<li>初始化语句</li>
<li>条件判断</li>
<li>循环体</li>
<li>步进语句</li>
</ol>
<ul>
<li>while(布尔表达式) {循环体; 步进表达式; }</li>
<li>do{ 循环体;步进语句; } while (布尔表达式);</li>
<li>for ( 初始化表达式 ; 布尔表达式 ; 步进表达式) { 循环体 }</li>
<li>break <ul>
<li>可以在switch语句当中，一旦执行，整个switch语句立刻结束。</li>
<li>还可以用在循环语句当中，一旦执行，整个循环语句立刻结束。打断循环。</li>
</ul>
</li>
<li>continue<ul>
<li>一旦执行，立刻跳过当前次循环剩余内容，马上开始下一次循环</li>
</ul>
</li>
</ul>
<p>1.如果条件判断从来没有满足过，那么for循环和while循环将会执行0次，但是do…while循环会执行至少一次。</p>
<p>2.for循环的变量在小括号当中定义，只有循环内部才可以使用。</p>
<h4 id="死循环"><a href="#死循环" class="headerlink" title="死循环"></a>死循环</h4><h4 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a>嵌套循环</h4><p>IDEA项目结构</p>
<p><img src="https://gitee.com/wuyueping/images/raw/master/img/idea_20211129210035.png" alt="image-20211129210033609"> </p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数据的概念：是一种容器，可以同时存放多个数据值。</p>
<p>数组的特点：</p>
<p>1.数组是一种引用数据类型</p>
<p>2.数组当中的多个数据，类型必须统一。</p>
<p>3.数组的长度在程序运行期间不可改变</p>
<p>数组的初始化，在内存当中创建一个数组，并且向其中赋予一些默认值。</p>
<p>两种常见的初始化：</p>
<p>1.动态初始化 ( 指定长度 )</p>
<ul>
<li>数据类型 [ ]  数组名称 = new 数据类型 [ 数组长度 ] </li>
</ul>
<p>2.静态初始化 ( 指定内容 )</p>
<ul>
<li>将具体的数据类型进行指定</li>
<li>数据类型 [ ] 数组名称 = new 数据类型 [ ] {元素1, 元素2 , …… }</li>
<li>数据类型 [ ] 数组名称 = {元素1……}</li>
</ul>
<h4 id="数组元素获取和访问"><a href="#数组元素获取和访问" class="headerlink" title="数组元素获取和访问"></a>数组元素获取和访问</h4><ul>
<li>直接打印数组名称，得到的是数组对应的 内存地址哈希值</li>
<li>索引值从0开始 , 一直到“ 数组的长度-1 ” 为止</li>
<li>使用动态初始化数组的时候，其中的元素将会自动拥有一个默认值。<ul>
<li>如果是整数类型，那么默认是0</li>
<li>如果是浮点类型，那么默认是0.0</li>
<li>如果是字符类型，那么默认是 ‘\u0000’</li>
<li>如果是布尔类型，默认是false</li>
<li>如果是引用类型，那么默认为null</li>
</ul>
</li>
<li>静态初始化其实也有默认值的过程，只不过系统自动马上将默认值替换成为了大括号当中的具体数值。</li>
</ul>
<h4 id="数组元素赋值"><a href="#数组元素赋值" class="headerlink" title="数组元素赋值"></a>数组元素赋值</h4><h4 id="获取数据的长度"><a href="#获取数据的长度" class="headerlink" title="获取数据的长度"></a>获取数据的长度</h4><p>数组名称.length </p>
<p>数组一旦创建，程序运行期间，长度不可改变。</p>
<h4 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h4><p>排序</p>
<h4 id="数组元素反转"><a href="#数组元素反转" class="headerlink" title="数组元素反转"></a>数组元素反转</h4><p>Reverse</p>
<p>数组元素反转，其实就是对称位置的元素互换 min==max min++ max–</p>
<h4 id="数组可以作为方法的参数："><a href="#数组可以作为方法的参数：" class="headerlink" title="数组可以作为方法的参数："></a>数组可以作为方法的参数：</h4><ul>
<li>当调用方法的时候，向方法的小括号进行传参，传递进去的其实是数组的地址值。</li>
</ul>
<h4 id="数组作为返回值"><a href="#数组作为返回值" class="headerlink" title="数组作为返回值"></a>数组作为返回值</h4><ul>
<li>返回的其实也是数组的地址值。</li>
</ul>
<h3 id="Java中的内存划分"><a href="#Java中的内存划分" class="headerlink" title="Java中的内存划分"></a>Java中的内存划分</h3><p>5个部分</p>
<ul>
<li>栈 stack<ul>
<li>存放的都是方法中的局部变量<ul>
<li>局部变量：方法的参数，或者是方法{} 内部的变量</li>
<li>作用域</li>
</ul>
</li>
</ul>
</li>
<li>堆 heap<ul>
<li>凡事new出来的东西，都在堆当中</li>
<li>堆内存里面的数据，都有默认值</li>
</ul>
</li>
<li>方法区 method area<ul>
<li>存储.class相关信息，包含方法的信息</li>
</ul>
</li>
<li>本地方法栈 native<ul>
<li>与操作系统相关</li>
</ul>
</li>
<li>寄存器 pc register<ul>
<li>与CPU相关</li>
</ul>
</li>
</ul>
<p>例：.class main方法进方法区—-main运行—-进栈 开辟空间 —- 数组名称=局部变量 —- new 堆当中 开辟内存空间 —- 0x666地址值 —-地址值赋值给栈当中的局部变量 —- </p>
<p><img src="https://gitee.com/wuyueping/images/raw/master/img/javase_20211202194830.png" alt="image-20211202194827868"></p>
<p>全局变量存放在 方法区</p>
<ul>
<li><p>与堆一样，是被线程共享的区域。在方法区中，存储了每个类的信息(包括类的名称、方法信息、字段信息)、静态变量、常量 以及编译器编译后的代码等。</p>
<p>在class文件中除了类的字段、方法、接口等描述信息外，还有一项信息是常量池，用来存储编译期间生成的字面量和符号引用。</p>
<p>在方法区中有一个非常重要的部分就是运行时常量池，他是每一个类或接口的常量池的运行时表示形式，在类和接口被加载到JVM后，对应的运行时常量池就被创建出来。当然并非class文件常量池中的内容才能进入运行时常量池，在运行期间也可将新的常量放入运行时常量池中，比如string的intern方法。</p>
</li>
<li><p>通过javac命令将Java文件编译为class文件。然后通过 javap -verbose xxx.class来解析class文件。</p>
</li>
<li><p>WinHex</p>
</li>
<li><p>总结：Java中的全局变量，也就是class的字段，存放在方法区中。</p>
</li>
</ul>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><ul>
<li>数组索引越界异常 ArrayIndexOutOfBoundsException</li>
<li>空指针异常 NullPointerException</li>
</ul>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><ul>
<li>面向过程<ul>
<li>强调步骤</li>
</ul>
</li>
<li>面向对象：当需要实现一个功能的时候，不关心具体的步骤，而是找一个已经具有该功能…<ul>
<li>强调对象</li>
<li>三大基本特征<ul>
<li>封装 继承 多态</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><ul>
<li>类<ul>
<li>是一组相关属性和行为的集合。可以看成是一类事物的模板，使用事物的属性特征和行为特征来描述该类事物</li>
</ul>
</li>
<li>属性：就是该事物的状态信息</li>
<li>行为：就是该事物能做什么</li>
<li>类与对象的关系<ul>
<li>类是对一类事物的描述，是抽象的。</li>
<li>对象是一类事物的实例，是具体的。</li>
<li>类是对象的模板，对象是类的实体。</li>
</ul>
</li>
<li>类的定义<ul>
<li>成员变量：对应事物的属性<ul>
<li>全局变量又叫成员变量，它是声明在类中、函数、静态语句块外的变量。全局变量又分为类变量(静态变量)、实例变量。</li>
<li>如果成员变量没有进行赋值，那将会有一个默认值，规则和数组一样。</li>
</ul>
</li>
<li>成员方法：对应事物的行为</li>
</ul>
</li>
<li>对象的创建和使用<ul>
<li>类名称 对象名 = new 类名称 ( ) ;</li>
<li>使用：对象名.成员变量名   对象名.成员方法名</li>
</ul>
</li>
</ul>
<h4 id="对象的内存图"><a href="#对象的内存图" class="headerlink" title="对象的内存图"></a>对象的内存图</h4><p>main方法运行进入栈空间 —– 创建了一个对象 进堆</p>
<p>！！！运行进栈 —- 方法完了 出栈</p>
<p><img src="https://gitee.com/wuyueping/images/raw/master/img/javase_20211203190806.png" alt="image-20211203190805393"></p>
<h4 id="使用对象类型作为方法参数"><a href="#使用对象类型作为方法参数" class="headerlink" title="使用对象类型作为方法参数"></a>使用对象类型作为方法参数</h4><p><img src="https://gitee.com/wuyueping/images/raw/master/img/javase_20211203193154.png" alt="image-20211203193152992"></p>
<h4 id="使用对象类型作为方法返回值"><a href="#使用对象类型作为方法返回值" class="headerlink" title="使用对象类型作为方法返回值"></a>使用对象类型作为方法返回值</h4><p><img src="https://gitee.com/wuyueping/images/raw/master/img/20211203193507.png" alt="image-20211203193505934"></p>
<h4 id="局部变量和成员变量"><a href="#局部变量和成员变量" class="headerlink" title="局部变量和成员变量"></a>局部变量和成员变量</h4><ul>
<li>定义的位置不一样<ul>
<li>局部变量：在方法的内部</li>
<li>成员变量：在方法的外部，直接写在类当中</li>
</ul>
</li>
<li>作用范围不一样<ul>
<li>局部变量：只有方法当中才可以使用，出了方法就不能再用</li>
<li>成员变量：整个类全都可以使用。</li>
</ul>
</li>
<li>默认值不一样<ul>
<li>局部变量：没有默认值，如果要使用，必须手动进行复制</li>
<li>成员变量：如果没有赋值，会有默认值，规则和数组一样。(参数在方法调用的时候必须会赋值)</li>
</ul>
</li>
<li>内存的位置不一样<ul>
<li>局部变量：栈内存</li>
<li>成员变量：堆内存</li>
</ul>
</li>
<li>生命周期不一样<ul>
<li>局部变量：随着方法进栈而诞生，随着方法出栈而消失</li>
<li>成员变量：随着对象创建而诞生，随着对象被垃圾回收而消失。</li>
</ul>
</li>
</ul>
<p>局部变量是存在于栈里，随着方法的调用而产生，随着方法的执行完毕而消失。因为栈是线程私有的，所以局部变量也是线程安全的。</p>
<p>成员变量：堆和方法区都存在。</p>
<p>方法区存有类信息、常量、静态变量，编译后的class文件等，既然是类信息，那么一个class类中的方法名，类名，成员变量名称等都属于该类的信息，也是存在于方法区中，也就是一个类中的成员变量名称是存在于方法区中的。但是在我们new一个对象后，这个对象上包含成员变量的值是放在堆中的，也就是new的这个对象包含着这个对象的成员变量的信息(也就是值)，但是这个对象上不会包含该类的方法，因为方法是共享的。</p>
<p>1、JVM只有一个堆区被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身。</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><ul>
<li>方法就是一种封装</li>
<li>关键字private也是一种封装<ul>
<li>超出本类范围之外就不能直接访问。通过Getter/Setter方法访问</li>
<li>对于基本类型当中的boolean值，Getter方法一定要写成isXxx的形式，而setXxx规则不变</li>
</ul>
</li>
</ul>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><ul>
<li>当方法的局部变量和类的成员变量重名，根据就近原则，优先使用局部变量。</li>
<li>如果需要访问本类当中的成员变量，需要使用：<ul>
<li>this.成员变量名</li>
</ul>
</li>
</ul>
<p>⚠️：通过谁调用的方法，谁就是this</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>专门用来创建对象的方法。通过关键字new来创建对象时，其实就是在调用构造方法。</p>
<p>public 类名称 ( 参数类型 参数名称 ) { 方法体 }</p>
<ul>
<li>构造方法的名称必须和所在的类名称完全一样，就连大小写也要一样</li>
<li>构造方法不要写返回值类型，连void都不写。</li>
<li>构造方法不能return一个具体的返回值</li>
<li>如果没有编写任何构造方法，那么编译器默认一个空参构造方法。</li>
<li>一旦编写了构造方法，那么编译器将没有默认的构造方法。</li>
<li>构造方法是可以重载的。方法名相同，参数列表不同</li>
</ul>
<h3 id="Java-bean"><a href="#Java-bean" class="headerlink" title="Java bean"></a>Java bean</h3><p>一个标准的类</p>
<p>1、所有的成员变量都要有private关键字修饰</p>
<p>2、为每一个成员变量编写一对Getter/Setter方法</p>
<p>3、一个无参的构造方法</p>
<p>4、一个全参的构造方法</p>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>application program interface 应用程序编程接口</p>
<h4 id="Scanner"><a href="#Scanner" class="headerlink" title="Scanner"></a>Scanner</h4><p>键盘输入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Scanner 类的功能，可以实现键盘输入数据到程序中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 只有java.lang包下的内容不需要导包，其他的包都需要import语句</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Scanner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 2.创建 System.in 从键盘输入</span></span><br><span class="line">        System.out.println(<span class="string">&quot;键盘输入的int数(按enter回车结束)&quot;</span>);</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> i = sc.nextInt();  <span class="comment">// 输入非法int数字：InputMismatchException</span></span><br><span class="line">        System.out.println(<span class="string">&quot;获取键盘输入的int数字: &quot;</span>+i);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;键盘输入的String数(按enter回车结束)&quot;</span>);</span><br><span class="line">        Scanner sc1 = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str = sc.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;获取键盘输入的int数字: &quot;</span>+str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h4><p>随机数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Random类用来生成随机数字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Random</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(getRandom(<span class="number">10</span>));</span><br><span class="line">        <span class="comment">// 创建一个默认随机数字</span></span><br><span class="line"><span class="comment">//        Random random = new Random();</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;nextInt()随机int数字: &quot;+ random.nextInt()); // 56426158</span></span><br><span class="line">        <span class="comment">// 0~9</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;nextInt(左闭右开区间)随机[0,10)int数字: &quot; + random.nextInt(10));</span></span><br><span class="line">        <span class="comment">// 1～10</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;1~10之间的数字：&quot;+(random.nextInt(10)+1));</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1~n [1,n]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Random().nextInt(n)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01RandomGame</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 随机数</span></span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> randomNum = r.nextInt(<span class="number">100</span>)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 键盘输入猜测的数字</span></span><br><span class="line">            System.out.print(<span class="string">&quot;请从键盘输入一个[1,100]之间的数字：&quot;</span>);</span><br><span class="line">            Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            <span class="keyword">int</span> guessNum = sc.nextInt();</span><br><span class="line">            <span class="keyword">if</span> (guessNum &gt; randomNum) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;猜的数字太大了&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (guessNum &lt; randomNum) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;猜的数字太小了&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;猜对了&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 跳出循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;游戏结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * java.lang.String</span></span><br><span class="line"><span class="comment"> * Java程序中所有字符串字面值都作为此类的实例实现</span></span><br><span class="line"><span class="comment"> * 字符串：</span></span><br><span class="line"><span class="comment"> * 1、字符串的内容永不可变</span></span><br><span class="line"><span class="comment"> * 2、正是因为字符串不可改变，所以字符串是可以共享使用的</span></span><br><span class="line"><span class="comment"> * 3、字符串效果上相当于是char[]字符数组，但是底层原理是byte[]字节数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//==========字符串创建============</span></span><br><span class="line"><span class="comment">// 1、空参构造方法 == 空白字符串</span></span><br><span class="line">String str1 = <span class="keyword">new</span> String();</span><br><span class="line">System.out.println(<span class="string">&quot;&quot;</span>+str1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、根据字符数组创建字符串</span></span><br><span class="line"><span class="keyword">char</span>[] charArray = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">String str2 = <span class="keyword">new</span> String(charArray);</span><br><span class="line">System.out.println(str2);  <span class="comment">// abc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、根据字节数组创建字符串</span></span><br><span class="line"><span class="keyword">byte</span>[] byteArray = &#123;<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>&#125;;</span><br><span class="line">String str3 = <span class="keyword">new</span> String(byteArray);</span><br><span class="line">System.out.println(str3);  <span class="comment">// abc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4、直接创建 直接写上双引号 就是字符串对象</span></span><br><span class="line">String str4 = <span class="string">&quot;直接创建&quot;</span>;</span><br><span class="line">System.out.println(str4);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===========</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.day01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字符串常量池：程序当中直接写上的双引号字符串，就在 [字符串常量池] 中。</span></span><br><span class="line"><span class="comment"> * 对于基本类型来说，==是进行 [数值] 的比较</span></span><br><span class="line"><span class="comment"> * 对于引用类型来说，==是进行 [地址值] 的比较</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 双引号直接写的字符串在常量池当中，new的不在池当中。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ==是进行对象的地址值比较，如果需要字符串的内容比较，可以使用两个方法：</span></span><br><span class="line"><span class="comment"> * public boolean equals(Object anObject) : 参数可以是任何对象，只有参数是一个字符串并且内容相同的才会给true,否则false</span></span><br><span class="line"><span class="comment"> * 1、任何对象都能用Object 接收。</span></span><br><span class="line"><span class="comment"> * 2、equal方法具有对称性</span></span><br><span class="line"><span class="comment"> * 3、如果比较对象一个常量一个变量，推荐把常量字符串写在前面</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * public boolean equalsIgnoreCase(String anotherString) : 忽略大小写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02String</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        String str2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="keyword">char</span>[] charArray = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">        String str3 = <span class="keyword">new</span> String(charArray);</span><br><span class="line">        System.out.println(str1 == str2); <span class="comment">// true</span></span><br><span class="line">        System.out.println(str1 == str3); <span class="comment">// false</span></span><br><span class="line">        System.out.println(str2 == str3); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        System.out.println(str1.equals(str3)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;abc&quot;</span>.equals(str1)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;ABC&quot;</span>.equalsIgnoreCase(str1)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// public int length() 获取字符串长度</span></span><br><span class="line">        System.out.println(<span class="string">&quot;abc&quot;</span>.length()); <span class="comment">// 3</span></span><br><span class="line">        <span class="comment">// public String concat(String str) 将当前字符串和参数字符串拼接成为返回值新的字符串</span></span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>.concat(<span class="string">&quot;world&quot;</span>));<span class="comment">// helloworld 新的字符串</span></span><br><span class="line">        <span class="comment">// public char charAt(int index) 获取指定索引为止的单个字符</span></span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>.charAt(<span class="number">1</span>)); <span class="comment">// e</span></span><br><span class="line">        <span class="comment">// public int indexOf(String str) 查找参数字符串在本来字符串当中出现的第一次索引位置</span></span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>.indexOf(<span class="string">&quot;l&quot;</span>)); <span class="comment">// 2</span></span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>.indexOf(<span class="string">&quot;H&quot;</span>)); <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 截取 [beginIndex,endIndex)</span></span><br><span class="line">        <span class="comment">// public String substring(int beginIndex, int endIndex)</span></span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>.substring(<span class="number">2</span>,<span class="number">3</span>)); <span class="comment">// l</span></span><br><span class="line">        <span class="comment">// public String substring(int beginIndex)</span></span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>.substring(<span class="number">2</span>)); <span class="comment">// llo</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        下面这种写法，字符串的内容仍然是没有改变的</span></span><br><span class="line"><span class="comment">        下面有两个字符串 &quot;hello&quot;  &quot;Java&quot;</span></span><br><span class="line"><span class="comment">        strA当中保存的是地址值</span></span><br><span class="line"><span class="comment">        本来地址值是hello的 哈希地址值</span></span><br><span class="line"><span class="comment">        后来地址值变成了 Java的哈希地址值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String strA = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        System.out.println(strA);</span><br><span class="line">        strA = <span class="string">&quot;Java&quot;</span>;</span><br><span class="line">        System.out.println(strA);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        public char[] toCharArray() 将当前字符串拆分成字符数组作为返回值</span></span><br><span class="line"><span class="comment">        public byte[] getBytes() 获取当前字符串底层的字节数组</span></span><br><span class="line"><span class="comment">        public String replace(CharSequence target, CharSequence replacement)</span></span><br><span class="line"><span class="comment">        将所有出现的老字符串替换成为新的字符串，返回替换之后的结果新字符串</span></span><br><span class="line"><span class="comment">        备注：CharSequence 意思是说可以接收字符串类型</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">char</span>[] chars = <span class="string">&quot;hello&quot;</span>.toCharArray();</span><br><span class="line">        System.out.println(Arrays.toString(chars)); <span class="comment">// [h, e, l, l, o]</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="string">&quot;hello&quot;</span>.getBytes();</span><br><span class="line">        System.out.println(Arrays.toString(bytes)); <span class="comment">// [104, 101, 108, 108, 111]</span></span><br><span class="line">        String newStr = <span class="string">&quot;hello&quot;</span>.replace(<span class="string">&quot;llo&quot;</span>, <span class="string">&quot;***&quot;</span>);</span><br><span class="line">        System.out.println(newStr); <span class="comment">// he***</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        分割字符串</span></span><br><span class="line"><span class="comment">        public String[] split(String regex) 按照参数的规则,将字符串切分成若干部分</span></span><br><span class="line"><span class="comment">        split方法的参数其实是一个正则表达式</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String split = <span class="string">&quot;aaa,bbb,ccc&quot;</span>;</span><br><span class="line">        String[] splitArray = split.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(splitArray)); <span class="comment">// [aaa, bbb, ccc]</span></span><br><span class="line">        System.out.println(Arrays.toString((<span class="string">&quot;xxx.yyy.zzz&quot;</span>).split(<span class="string">&quot;\\.&quot;</span>))); <span class="comment">// [xxx, yyy, zzz]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建对象的标准格式：</span></span><br><span class="line"><span class="comment"> * 类名称 对象名 = new 类名称();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 匿名对象：</span></span><br><span class="line"><span class="comment"> * 只有右边的对象，没有左边的名字和赋值运算符。</span></span><br><span class="line"><span class="comment"> * new 类名称()</span></span><br><span class="line"><span class="comment"> * 注意：匿名对象只能使用唯一的一次，下次再用不得不再创建一个新对象</span></span><br><span class="line"><span class="comment"> * 如果确定有一个对象只需要使用唯一的一次，就可以用匿名对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 匿名对象作为方法的参数</span></span><br><span class="line"><span class="comment"> * 匿名对象作为返回值</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h3 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个长度为3的数组，里面用来存放Person类型的对象</span></span><br><span class="line"><span class="comment">// 缺点 一旦创建 程序运行期间长度不可以发生改变</span></span><br><span class="line">Person[] arrays = <span class="keyword">new</span> Person[<span class="number">3</span>];</span><br></pre></td></tr></table></figure>



<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.day01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组的长度不可以发生改变</span></span><br><span class="line"><span class="comment"> * ArrayList 集合的长度是可以任意变化的</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 对于 ArrayList 有一个尖括号&lt;E&gt; 代表泛型</span></span><br><span class="line"><span class="comment"> * 泛型只能是引用类型，不能是基本类型。</span></span><br><span class="line"><span class="comment"> * 使用基本类型对应的包装类</span></span><br><span class="line"><span class="comment"> * jdk5+ 支持自动装箱、自动拆箱</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ArrayList集合，直接打印得到的不是地址值，而是内容(toString重写)</span></span><br><span class="line"><span class="comment"> * public boolean add(E e)</span></span><br><span class="line"><span class="comment"> * public E get(int index)</span></span><br><span class="line"><span class="comment"> * public E remove(int index)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01ArrayList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建ArrayList 集合，集合名称为list 装的全都是String字符串类型的数据</span></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 集合中添加元素</span></span><br><span class="line">        <span class="keyword">boolean</span> wu = list.add(<span class="string">&quot;wu&quot;</span>);</span><br><span class="line">        System.out.println(wu);</span><br><span class="line">        list.add(<span class="string">&quot;zi&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;mei mei&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">// 从集合中获取元素</span></span><br><span class="line">        String str2 = list.get(<span class="number">1</span>);</span><br><span class="line">        System.out.println(str2); <span class="comment">// zi</span></span><br><span class="line">        <span class="comment">// 从集合中删除元素</span></span><br><span class="line">        String remove = list.remove(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;被删除的是: &quot;</span>+remove);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        System.out.println(<span class="string">&quot;集合的长度: &quot;</span>+list.size()); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 泛型</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="静态static关键字"><a href="#静态static关键字" class="headerlink" title="静态static关键字"></a>静态static关键字</h3><p>一旦用了static关键字，那么这样的内容不再属于自己，而是属于类的，所以凡事本类的对象的，都共享同一份。</p>
<h4 id="static关键字修饰成员"><a href="#static关键字修饰成员" class="headerlink" title="static关键字修饰成员"></a>static关键字修饰成员</h4><h5 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h5><ul>
<li>如果一个成员变量使用static关键字，那么这个变量不再属于对象自己，而是属于所在的类，多个对象共享同一份数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.day01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03StaticField</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;x1&quot;</span>,<span class="number">20</span>);</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="string">&quot;x2&quot;</span>,<span class="number">21</span>);</span><br><span class="line">        <span class="comment">// Person.room = &quot;101教室&quot;;</span></span><br><span class="line">        p1.room = <span class="string">&quot;101教室&quot;</span>;</span><br><span class="line">        <span class="comment">//  p1--姓名:x1;年龄:20;教室:101教室;id=1</span></span><br><span class="line">        System.out.println(<span class="string">&quot;p1--姓名:&quot;</span>+p1.getName()+<span class="string">&quot;;年龄:&quot;</span>+p1.getAge()+<span class="string">&quot;;教室:&quot;</span>+p1.room+<span class="string">&quot;;id=&quot;</span>+p1.getId());</span><br><span class="line">        <span class="comment">//  p2--姓名:x2;年龄:21;教室:101教室;id=2</span></span><br><span class="line">        System.out.println(<span class="string">&quot;p2--姓名:&quot;</span>+p2.getName()+<span class="string">&quot;;年龄:&quot;</span>+p2.getAge()+<span class="string">&quot;;教室:&quot;</span>+p2.room+<span class="string">&quot;;id=&quot;</span>+p2.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h5><ul>
<li>static修饰的成员方法，那么这个方法就是静态方法。静态方法不属于对象的，而是属于类的。<ul>
<li>对于静态方法来说，可以通过对象名进行调用[编译之后也会被javac翻译成”类名称.静态方法名”]，也可以直接通过类名称来调用。</li>
</ul>
</li>
<li>如果没有static关键字，那么必须首先创建对象，然后通过对象才能使用它。</li>
</ul>
<p>无论是成员变量还是成员方法，如果有了static，都推荐使用类名称进行调用。</p>
<p>静态变量：类名称.静态变量;</p>
<p>静态方法：类名称.静态方法();</p>
<p>⚠️：</p>
<p>1、静态不能直接访问非静态。</p>
<p>原因：因为在内存当中是【先】有的静态内容，【后】有的非静态内容</p>
<p>2、静态方法中不能使用this。</p>
<p>原因：this代表当前对象。通过谁调用的方法，谁就是当前对象。</p>
<h5 id="内存图"><a href="#内存图" class="headerlink" title="内存图"></a>内存图</h5><p>根据类名称方法静态成员变量的时候，全程和对象就没有关系，只和类有关系。</p>
<p><img src="https://gitee.com/wuyueping/images/raw/master/img/static_20210621151752.jpeg" alt="4A5B67EE-4C4C-4C62-B500-D933AFEBF99B"></p>
<h5 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.day01;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">静态代码块的格式是：</span></span><br><span class="line"><span class="comment">public class 类名称&#123;</span></span><br><span class="line"><span class="comment">    static &#123;</span></span><br><span class="line"><span class="comment">     // 静态代码块的内容</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">特点：当第一次用到本类时，静态代码块执行[唯一的一次]。</span></span><br><span class="line"><span class="comment">静态内容总是优先于非静态，所以静态代码块比构造方法先执行。</span></span><br><span class="line"><span class="comment">用途：</span></span><br><span class="line"><span class="comment">用来一次性地对静态成员变量进行赋值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonStatic</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonStatic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;无参构造方法执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.day01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java.util.Arrays 数组相关的工具类，提供大量的静态方法，用来实现数组常见的操作</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">sort排序：按照默认升序(从小到大)对数组的元素进行排序</span></span><br><span class="line"><span class="comment">备注：</span></span><br><span class="line"><span class="comment">1、如果是数值，sort默认按照升序从小到大</span></span><br><span class="line"><span class="comment">2、如果是字符串，sort默认按照字母升序</span></span><br><span class="line"><span class="comment">3、如果是自定义的类型，那么这个自定义的类需要有Comparable活着Comparable接口的支持。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03Arrays</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] intArrays = &#123;<span class="number">9</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">12</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(intArrays)); <span class="comment">// [9, 4, 10, 12]</span></span><br><span class="line">        Arrays.sort(intArrays);</span><br><span class="line">        System.out.println(Arrays.toString(intArrays)); <span class="comment">// [4, 9, 10, 12]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.day01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03Math</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 绝对值</span></span><br><span class="line">        System.out.println(Math.abs(<span class="number">3.14</span>)); <span class="comment">// 3.14</span></span><br><span class="line">        System.out.println(Math.abs(-<span class="number">1</span>)); <span class="comment">// 1</span></span><br><span class="line">        <span class="comment">// 向上取整</span></span><br><span class="line">        System.out.println(Math.ceil(<span class="number">3.14</span>)); <span class="comment">// 4.0</span></span><br><span class="line">        <span class="comment">// 向下取整</span></span><br><span class="line">        System.out.println(Math.floor(<span class="number">3.9</span>)); <span class="comment">// 3.0</span></span><br><span class="line">        <span class="comment">// 四舍五入</span></span><br><span class="line">        System.out.println(Math.round(<span class="number">3.5</span>)); <span class="comment">// 4</span></span><br><span class="line">        System.out.println(Math.PI);</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// -10.8~5.9 之间 绝对值大于6 或者2.1的整数有多少个</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (<span class="keyword">int</span>) -<span class="number">10.8</span>; i&lt;=<span class="number">5.9</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Math.abs(i)&gt;<span class="number">6</span> || Math.abs(i)&lt;<span class="number">2.1</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(count); <span class="comment">// 9</span></span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// -10.8~5.9 之间 绝对值大于6 或者2.1的整数有多少个 --- double版本</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">double</span> i = Math.ceil(-<span class="number">10.8</span>); i&lt;=<span class="number">5.9</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Math.abs(i)&gt;<span class="number">6</span> || Math.abs(i)&lt;<span class="number">2.1</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(count); <span class="comment">// 9</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承是多态的前提，如果没有继承，就没有多态。</p>
<p>继承主要解决的问题是：共性抽取。</p>
<p>父类：也可以叫基类、超类</p>
<p>子类：也可以叫派生类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extends</span><br></pre></td></tr></table></figure>

<h4 id="继承中成员变量的访问特点"><a href="#继承中成员变量的访问特点" class="headerlink" title="继承中成员变量的访问特点"></a>继承中成员变量的访问特点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在父子类的继承关系当中，如果成员变量重名，则创建子类对象时，访问有两种方式：</span></span><br><span class="line"><span class="comment">1、直接通过子类对象访问成员变量：</span></span><br><span class="line"><span class="comment">   等号左边是谁，就优先用谁，没有则向上找。</span></span><br><span class="line"><span class="comment">2、间接通过成员方法访问访问成员变量。</span></span><br><span class="line"><span class="comment">   该方法属于谁，就优先用谁。没有则向上找。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="子类方法中重名"><a href="#子类方法中重名" class="headerlink" title="子类方法中重名"></a>子类方法中重名</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">局部变量：          直接写</span></span><br><span class="line"><span class="comment">本类的成员变量：     this.成员变量</span></span><br><span class="line"><span class="comment">父类的成员变量：     super.成员变量</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="成员方法-1"><a href="#成员方法-1" class="headerlink" title="成员方法"></a>成员方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在父子类的继承关系中，创建子类对象，访问成员方法的规则：</span></span><br><span class="line"><span class="comment">	创建的对象是谁new，就优先用谁，如果没有就想上找。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	无论是成员方法还是成员变量，如果没有都是向上找父类，绝对不会向下找子类。	</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">重写 override  == 覆盖、覆写</span></span><br><span class="line"><span class="comment">概念：在继承关系中，方法的名称一样，参数列表也一样。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">重写override</span></span><br><span class="line"><span class="comment">重载 overload：方法的名称一样，参数列表【不一样】</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">方法的覆盖重写特点：创建的是子类对象，则优先用子类方法。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">方法的覆盖重写的注意事项：</span></span><br><span class="line"><span class="comment">1、必须保证父子类之间方法的名称相同，参数列表也相同。</span></span><br><span class="line"><span class="comment">@Override：写在方法前面，用来判断方法是否是有效的覆盖重写</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2、子类方法的返回值必须小于等于父类方法的返回值范围</span></span><br><span class="line"><span class="comment">java.lang.Object类是所有类的公共最高父类。</span></span><br><span class="line"><span class="comment">java.lang.String是Object子类</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3、子类方法的权限必须大于等于父类方法的权限修饰符。</span></span><br><span class="line"><span class="comment">public &gt; protected &gt; (default) &gt; private </span></span><br><span class="line"><span class="comment">备注：(default)不是关键字default，而是什么都不写，留空</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>设计原则：</p>
<p>对于已经投入使用的类，尽量不要进行修改。推荐定一个新的类，来重复利用其中共性内容，并且添加改动新内容。</p>
<h4 id="继承中构造方法"><a href="#继承中构造方法" class="headerlink" title="继承中构造方法"></a>继承中构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">继承关系中，父子类构造方法的访问特点：</span></span><br><span class="line"><span class="comment">1、子类构造方法当中，有一个默认隐含的super() 调用。所以一定是先调用的父类构造，后执行的子类构造</span></span><br><span class="line"><span class="comment">2、可以通过super关键字来子类构造调用父类重载构造方法。</span></span><br><span class="line"><span class="comment">3、super的父类构造调用，必须是子类构造方法的第一个语句。 不能一个子类构造调用多次super构造。</span></span><br><span class="line"><span class="comment">只有子类构造方法才能调用父类构造方法。</span></span><br><span class="line"><span class="comment">总结</span></span><br><span class="line"><span class="comment">子类必须调用父类构造方法，不写赠送super()，写了则用写定的super调用。super只能有一个还必须是第一个。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h4 id="super"><a href="#super" class="headerlink" title="super"></a>super</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">super关键字的用法有三种</span></span><br><span class="line"><span class="comment">1、在子类的成员方法中，访问父类的成员变量。</span></span><br><span class="line"><span class="comment">2、在子类的成员方法中，访问父类的成员方法。</span></span><br><span class="line"><span class="comment">3、在子类的构造方法中，访问父类的构造方法。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h4 id="this-1"><a href="#this-1" class="headerlink" title="this"></a>this</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">super关键字用来访问父类内容，this关键字用来方法本类内容，用法有三种：</span></span><br><span class="line"><span class="comment">1、在本类的成员方法中，访问本类的成员变量。</span></span><br><span class="line"><span class="comment">2、在本来的成员方法中，访问本类的另一个成员方法。</span></span><br><span class="line"><span class="comment">3、在本类的构造方法中，访问本类的另一个构造方法。</span></span><br><span class="line"><span class="comment">在第三种方法中要注意：</span></span><br><span class="line"><span class="comment">this()调用也必须是构造方法的第一个语句，唯一一个。</span></span><br><span class="line"><span class="comment">super和this两种构造调用，不能同时使用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">20</span>;</span><br><span class="line">        System.out.println(num);       <span class="comment">// 20</span></span><br><span class="line">        System.out.println(<span class="keyword">this</span>.num);  <span class="comment">// 10</span></span><br><span class="line">        System.out.println(<span class="keyword">super</span>.num); <span class="comment">//30 父类</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>this和super图解</p>
<p>1、程序运行 —– 进入方法区</p>
<p>2、main方法进栈—–创建子类对象 Zi zi </p>
<p>3、堆当中new Zi —– 子类内容 [父类内容]</p>
<p>4、子类调用方法 —– 方法进栈</p>
<p><img src="https://gitee.com/wuyueping/images/raw/master/img/extends_20210623163209.jpeg" alt="5D20587D-D0BF-4E6A-8FA9-2637D5F43D07"></p>
<p>Java语言是单继承的。</p>
<p>一个类的直接父类只能有唯一一个。</p>
<p>Java语言可以多级继承。</p>
<p>一个子类的直接父类是唯一的，但是一个父类可以拥有很多个子类。</p>
<h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><h2 id="web前端"><a href="#web前端" class="headerlink" title="web前端"></a>web前端</h2><h2 id="web后端"><a href="#web后端" class="headerlink" title="web后端"></a>web后端</h2><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><h2 id="运维"><a href="#运维" class="headerlink" title="运维"></a>运维</h2><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h1 id="File类和IO流程"><a href="#File类和IO流程" class="headerlink" title="File类和IO流程"></a>File类和IO流程</h1><h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1>
        
      </div>
      
      <aside id="article-toc" role="navigation" class="fixed" >
    <div id="article-toc-inner">
        <strong class="sidebar-title">文章目录</strong>
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF"><span class="toc-text">学习路线</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%A7%E7%BA%B2"><span class="toc-text">大纲</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">计算机基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E5%88%B6"><span class="toc-text">进制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82"><span class="toc-text">字节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%8F%90%E7%A4%BA%E7%AC%A6"><span class="toc-text">命令提示符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E5%B9%B3%E5%8F%B0"><span class="toc-text">跨平台</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JRE%E3%80%81JDK"><span class="toc-text">JRE、JDK</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%AE%89%E8%A3%85%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE-%E7%95%A5"><span class="toc-text">Java安装和环境变量配置(略)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A"><span class="toc-text">注释</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Javadoc%E5%91%BD%E4%BB%A4"><span class="toc-text">Javadoc命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="toc-text">文档注释的格式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-text">标识符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F"><span class="toc-text">常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-text">变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">数据类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ASCII%E7%A0%81%E8%A1%A8"><span class="toc-text">ASCII码表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="toc-text">方法调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD"><span class="toc-text">方法重载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96"><span class="toc-text">编译器优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-text">流程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="toc-text">顺序结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84"><span class="toc-text">选择结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84"><span class="toc-text">循环结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E5%BE%AA%E7%8E%AF"><span class="toc-text">死循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF"><span class="toc-text">嵌套循环</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E8%8E%B7%E5%8F%96%E5%92%8C%E8%AE%BF%E9%97%AE"><span class="toc-text">数组元素获取和访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E8%B5%8B%E5%80%BC"><span class="toc-text">数组元素赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="toc-text">获取数据的长度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84"><span class="toc-text">遍历数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%8F%8D%E8%BD%AC"><span class="toc-text">数组元素反转</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95%E7%9A%84%E5%8F%82%E6%95%B0%EF%BC%9A"><span class="toc-text">数组可以作为方法的参数：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text">数组作为返回值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%88%92%E5%88%86"><span class="toc-text">Java中的内存划分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-text">异常</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-text">类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE"><span class="toc-text">对象的内存图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0"><span class="toc-text">使用对象类型作为方法参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text">使用对象类型作为方法返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-text">局部变量和成员变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-text">封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this"><span class="toc-text">this</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-bean"><span class="toc-text">Java bean</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#API"><span class="toc-text">API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Scanner"><span class="toc-text">Scanner</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Random"><span class="toc-text">Random</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String"><span class="toc-text">String</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1"><span class="toc-text">匿名对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84"><span class="toc-text">对象数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList"><span class="toc-text">ArrayList</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81static%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">静态static关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#static%E5%85%B3%E9%94%AE%E5%AD%97%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98"><span class="toc-text">static关键字修饰成员</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-text">成员变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-text">成员方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%9B%BE"><span class="toc-text">内存图</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-text">静态代码块</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Arrays"><span class="toc-text">Arrays</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Math"><span class="toc-text">Math</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-text">泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%BF%E9%97%AE%E7%89%B9%E7%82%B9"><span class="toc-text">继承中成员变量的访问特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E7%B1%BB%E6%96%B9%E6%B3%95%E4%B8%AD%E9%87%8D%E5%90%8D"><span class="toc-text">子类方法中重名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95-1"><span class="toc-text">成员方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-text">继承中构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#super"><span class="toc-text">super</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#this-1"><span class="toc-text">this</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1"><span class="toc-text">抽象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-text">接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-text">多态</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6"><span class="toc-text">进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#web%E5%89%8D%E7%AB%AF"><span class="toc-text">web前端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#web%E5%90%8E%E7%AB%AF"><span class="toc-text">web后端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">数据库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%86%E6%9E%B6"><span class="toc-text">框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%BB%B4"><span class="toc-text">运维</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1"><span class="toc-text">微服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E6%88%98"><span class="toc-text">实战</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#File%E7%B1%BB%E5%92%8CIO%E6%B5%81%E7%A8%8B"><span class="toc-text">File类和IO流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-text">网络编程</span></a></li></ol>
    </div>
</aside>
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/11/Java%E5%9F%BA%E7%A1%80/" data-id="ckprtluv60000k1gp3qyrgkoi" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/07/14/SpringBoot/" id="article-nav-newer" class="article-nav-link-wrap">
      <span class="article-nav-caption">Newer</span>
      <div class="article-nav-title">
        
          SpringBoot2
        
      </div>
    </a>
  
  
    <a href="/2021/05/24/%E6%AF%8F%E6%97%A5%E8%AE%B0%E5%BD%95/" id="article-nav-older" class="article-nav-link-wrap">
      <span class="article-nav-caption">Older</span>
      <div class="article-nav-title">每日记录</div>
    </a>
  
</nav>

  
</article>

</section>
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 wuyp<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> with 
      theme_by <a href="http://hexo.io/" target="_blank">mango</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">主页</a>
  
    <a href="/archives/" class="mobile-nav-link">归档</a>
  
    <a href="/about/" class="mobile-nav-link">关于.</a>
  
</nav>
    


<script src="//code.jquery.com/jquery-2.0.3.min.js"></script>

  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>